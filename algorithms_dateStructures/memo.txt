アルゴリズムの三大処理
　順次処理
　分岐処理
　繰り返し処理
=>構造化プログラミング
=>3つの処理を組み合わせてプログラムを設計する方法論

アルゴリズムの性質(以下を満たさなければならない)
　正当性
　　指定された条件を満たす入力値が与えられたとき、必ず正しく動作する（正しい出力結果を得る）ことを保証する
　　=>アサーション(任意の位置で、その時点において、満たさなければならない条件が成立しているかどうかを判定)を用いて示す
　　部分正当性
　　=>必ずアサーションが成立する
　　=>プログラムがその位置で停止すれば、その時点での答えは正しい
　停止性
　　いかなる条件の入力値が与えられても、有限時間内に必ず正しく停止することを保証する
　　=>必ず有限回数の繰り返しで終了条件が成立
　　!= 無限ループ　
--------------------------------------------
データ構造
  リスト
  　連結リスト
  　　単方向リスト
  　　循環リスト
  　　双方向リスト
　連想記憶
　　=>ハッシュテーブル(key, value)
　スタック
　　=>LIFO(Last In, First Out)
　　=>データを積むことをpush，スタックからデータを取り出すことをpupと呼ぶ
  キュー
  　=>FIFO(First In First Out)
   リングバッファ
    =>キューの配列の先頭と末尾を結びつけ、キューの使用回数を無制限にする
　ツリー構造
  　node => ツリー構造の中のデータ
　　brunch =>	nodeとnodeとのつながり
　　root => ツリー構造のnodeのうち、最上位のもの
　　parent node => branchで結ばれたnode同士のうち、上位のもの
　　child node => branchで結ばれたnode同士のうち、下位のもの
　　sibling node => 同じparent nodeを持つchild node

　　binary tree(二分木)
　　　=>ツリー構造のうちchild nodeが2つのもの
　　　ヒープ構造
　　　　=>binary treeの各節点にデータを保持し、parent nodeが2つのchild nodeのデータよりも小さくなるように作られたデータ構造のこと
--------------------------------------------
サーチアルゴリズム
　リニアサーチ(線形探索)
　　=>リストの先頭から終端に向かって目的の要素を探し出すアルゴリズム
　　=>実装が単純
　　=>終了までのステップ数がリストの大きさに依存、データ数が多い場合は向かない
　バイナリサーチ(二分探索)
　　=>中央値と比較し、一致すれば終了。目的の要素より大きければ検索の範囲を中央値より前半の部分にする
　　=>検索が早い
　　=>要素が昇順(降順)で並べ替えられている必要があり、そもそも数値などのソートできるデータにしか使えない
--------------------------------------------
ソートアルゴリズム
　バブルソート
  =>a[0]とa[1]を比べ、a[0] < a[1]であればa[0] = a[1]とする
  =>a[1]とa[2]を比べ、a[1] < a[2]であればa[1] = a[2]とする
  =>それをa[l - 1]まで繰り返す
  =>a[1]、a[2]と繰り返す
  =>a[l - 1]から最大値または最小値が確定していく
選択ソート
　=>a[0]をa[1]..a[l - 1]と配列の最後まで比べ、a[0] より大きくなる最大値をa[0] = a[x]とする
  =>a[1]、a[2]と繰り返す
  =>a[0]から最大値または最小値が確定していく
挿入ソート
  =>a[0]とa[1]を比較
  =>以降a[2]..a[l - 1]を適切な位置に挿入
　シェルソート
　　=>適当な間隔で挿入ソートをし、間隔を小さくしながら挿入ソートを繰り返す
　　=>最後に全体に挿入ソートを行う